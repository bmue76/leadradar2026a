# 02_DB — Datenmodell & Migrations (LeadRadar2026A)

Stand: 2026-01-11

## Grundsätze (verbindlich)

- **Tenant-first / leak-safe:** Jede tenant-owned Entity hat ein Pflichtfeld `tenantId`.
  - Lookups immer `{ id, tenantId }` bzw. `findFirst({ where: { id, tenantId } })`.
  - Bei Scope mismatch: **404 NOT_FOUND** (kein Leak).
- **Workflow:** DB → API → UI → Tests/Proof → Schlussrapport → Commit/Push
- **Prisma v7 Policy:** Connection URLs (z. B. `DATABASE_URL`) sind **nicht** im `schema.prisma`,
  sondern in `prisma.config.ts` konfiguriert.

---

## Core Domain Models (TP 1.0)

Dieses Teilprojekt ergänzt das DB-Fundament um die GoLive-Core Entities:

- **Form** + **FormField**
- **Lead** + **LeadAttachment**
- **ExportJob**

### Enums

- `FormStatus`: `DRAFT | ACTIVE | ARCHIVED`
- `FieldType` (minimal start, erweiterbar):
  `TEXT | TEXTAREA | SINGLE_SELECT | MULTI_SELECT | EMAIL | PHONE | CHECKBOX`
- `AttachmentType` (erweiterbar):
  - Basis: `IMAGE | PDF | OTHER`
  - **TP 3.5 (MVP):** zusätzlich `BUSINESS_CARD_IMAGE` (Visitenkartenfoto)
- `ExportJobStatus`: `QUEUED | RUNNING | DONE | FAILED`
- `ExportJobType`: `CSV` (später erweiterbar)

### Form

Felder (minimal robust):

- `id` (cuid), `tenantId` (FK)
- `name`, `description?`
- `status` (FormStatus)
- `config?` (Json)
- `createdAt`, `updatedAt`

Relationen:

- `fields[]`, `leads[]`

Indizes:

- `@@index([tenantId, status])`

### FormField

Felder:

- `id`, `tenantId`, `formId`
- `key` (stabiler Identifier), `label`, `type` (FieldType)
- `required`, `isActive`, `sortOrder`
- `placeholder?`, `helpText?`, `config?` (Json)
- `createdAt`, `updatedAt`

Constraints / Indizes:

- Unique: `@@unique([formId, key])` (stabil, pro Form eindeutig)
- Index: `@@index([tenantId, formId, isActive, sortOrder])`

### Lead (inkl. Idempotency + Soft-delete vorbereitet)

Felder:

- `id`, `tenantId`, `formId`
- `clientLeadId` (String, idempotency key)
- `capturedAt`
- `values` (Json), `meta?` (Json)

Idempotency:

- Unique: `@@unique([tenantId, clientLeadId])`
  - verhindert Doppelposts bei Retry (Mobile/Online-first).

Soft-delete Vorbereitung:

- `isDeleted` (default false)
- `deletedAt?`, `deletedReason?`, `deletedByUserId?`

Index:

- `@@index([tenantId, formId, capturedAt])`

### LeadAttachment (TP 1.0, erweitert in TP 3.5)

Felder:

- `id`, `tenantId`, `leadId`
- `type` (AttachmentType)
- `filename` (Originalname, sanitisiert), `mimeType`, `sizeBytes`
- `storageKey` (safe relative key, kein absoluter Pfad)
- `createdAt`, `updatedAt`

Index:

- `@@index([tenantId, leadId])`

#### StorageKey Konvention (TP 3.5 — DEV Stub)

Phase 1 (ONLINE-only, lokal im Repo):

- Root: `.tmp_attachments/`
- Key (relativ, leak-safe, ohne `..`):
  - `<tenantId>/<leadId>/<attachmentId>.<ext>`

Beispiele:

- `cmk...tenant/cmk...lead/cmk...att.jpg`
- `tenant_demo/form_demo_1/att_123.webp`

Wichtig:

- `storageKey` ist **immer ein relativer Key** (safe subset), keine absoluten Pfade.
- Zugriff auf Attachments erfolgt **nie public** über statische URLs, sondern nur über auth-protected Endpoints.

---

## Exports (TP 1.8 + TP 3.4)

### ExportJob

Felder:

- `id`, `tenantId`
- `type` (ExportJobType), `status` (ExportJobStatus)
- `params?` (Json)
- `resultStorageKey?`
- `queuedAt`, `startedAt?`, `finishedAt?`, `updatedAt`

Index:

- `@@index([tenantId, status, updatedAt])`

---

## Mobile Device Auth (TP 2.5)

Models:

- `MobileApiKey` (tokenHash/keyHash + prefix; Klartext nie gespeichert)
- `MobileDevice` (1:1 an ApiKey gebunden)
- `MobileDeviceForm` (Assignments, Replace-Strategy)

Enums:

- `MobileApiKeyStatus`: `ACTIVE | REVOKED`
- `MobileDeviceStatus`: `ACTIVE | DISABLED`

---

## Device Provisioning (TP 3.0)

Ziel: Device-Onboarding ohne manuelles Copy/Paste von ApiKeys.

### Enum

- `MobileProvisionTokenStatus`: `ACTIVE | REVOKED | USED`
  - Zusätzlich kann die UI **EXPIRED** anzeigen (computed: `ACTIVE` + `expiresAt <= now`).

### Model: MobileProvisionToken

Kernidee:
- Admin erstellt Provision Token (Klartext nur 1x).
- Mobile/App claimt Token → erstellt **Device + ApiKey + Assignments**.
- Token wird atomar auf `USED` gesetzt, invalid/expired/revoked/used → 401 ohne Leaks.

Felder (MVP):

- `id` (cuid), `tenantId`
- `prefix` (für Liste / Ops)
- `tokenHash` (unique) – niemals Klartext speichern
- `status` (ACTIVE/REVOKED/USED)
- `expiresAt`
- `usedAt?`
- `usedByDeviceId?` (FK auf `MobileDevice`, optional)
- Optionaler “Wunsch” (Admin UX):
  - `requestedDeviceName?`
  - `requestedFormIds?` (Json string[])

Indizes:
- `@@index([tenantId, status, expiresAt])`
- `@@index([tenantId, createdAt])`
- `@@index([prefix, status])`

---

## Migration-Strategie

- Prisma Migrate ist die einzige Quelle der Wahrheit.
- Jede Schema-Änderung ⇒ neue Migration.
- Seed ist **idempotent** und darf mehrfach laufen (keine Duplikate).
