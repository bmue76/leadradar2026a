/**
 * LeadRadar2026A — Prisma Schema (Prisma ORM v7)
 * IMPORTANT (Prisma v7):
 * - Connection URLs are configured in prisma.config.ts (NOT here).
 */

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

//
// Enums
//
enum FormStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

enum FieldType {
  TEXT
  TEXTAREA
  SINGLE_SELECT
  MULTI_SELECT
  EMAIL
  PHONE
  CHECKBOX
}

enum AttachmentType {
  BUSINESS_CARD_IMAGE
  IMAGE
  PDF
  OTHER
}

enum ExportJobStatus {
  QUEUED
  RUNNING
  DONE
  FAILED
}

enum ExportJobType {
  CSV
}

//
// TP 2.5 — Mobile Device Auth
//
enum MobileApiKeyStatus {
  ACTIVE
  REVOKED
}

enum MobileDeviceStatus {
  ACTIVE
  DISABLED
}

//
// TP 3.0 — Device Provisioning
//
enum MobileProvisionTokenStatus {
  ACTIVE
  REVOKED
  USED
}

//
// TP 3.3 — Events (Messen)
//
enum EventStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

//
// TP 4.1 — OCR
//
enum LeadOcrKind {
  BUSINESS_CARD
}

//
// TP 4.3 — OCR (Lifecycle + Engine + Modes) + Lead Contact Source
//
enum LeadOcrMode {
  ON_DEVICE_LATIN
  SERVER_FALLBACK
}

enum LeadOcrStatus {
  PENDING
  COMPLETED
  FAILED
}

enum LeadOcrEngine {
  MLKIT
  SERVER_PLACEHOLDER
}

enum LeadContactSource {
  MANUAL
  OCR_MOBILE
  OCR_ADMIN
}

//
// Core base models
//
model Tenant {
  id        String   @id @default(cuid())
  slug      String   @unique @default(cuid()) // default so public registration can create tenant without explicitly setting slug
  name      String
  country   String // ISO2, e.g. "CH"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Branding (Tenant Logo) — TP 2.0
  // IMPORTANT: do not transform/optimize logo; scaling happens only in UI (max-height, width auto, object-fit contain).
  logoKey          String?
  logoMime         String?
  logoSizeBytes    Int?
  logoOriginalName String?
  logoUpdatedAt    DateTime?
  logoWidth        Int?
  logoHeight       Int?

  // Relations
  users           User[]
  forms           Form[]
  formFields      FormField[]
  leads           Lead[]
  leadAttachments LeadAttachment[]
  exportJobs      ExportJob[]

  // TP 3.3 — Events
  events Event[]

  // TP 2.5 — Mobile Device Auth
  mobileApiKeys     MobileApiKey[]
  mobileDevices     MobileDevice[]
  mobileAssignments MobileDeviceForm[]

  // TP 3.0 — Provisioning
  mobileProvisionTokens MobileProvisionToken[]

  // TP 4.1/4.3 — OCR
  leadOcrResults LeadOcrResult[]

  @@index([country])
}

model User {
  id       String  @id @default(cuid())
  tenantId String?

  email String @unique

  // Role/tenant context (MVP: owner-only; roles later)
  role String @default("TENANT_OWNER")

  // NextAuth/Auth.js expects emailVerified
  emailVerified DateTime?

  // Optional profile
  name      String?
  firstName String?
  lastName  String?
  image     String?

  // Optional local auth fields (legacy/future)
  passwordHash String?
  lastLoginAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant? @relation(fields: [tenantId], references: [id], onDelete: SetNull)

  // Auth.js relations (PrismaAdapter)
  accounts Account[]
  sessions Session[]

  // Legacy/optional flows (can be used later)
  passwordResetTokens     PasswordResetToken[]
  emailVerificationTokens EmailVerificationToken[]

  // TP 2.5 — MobileApiKey (optional audit)
  createdMobileApiKeys MobileApiKey[]

  // TP 4.3 — OCR corrections (optional audit)
  correctedLeadOcrResults LeadOcrResult[] @relation("OcrCorrectedBy")

  @@index([tenantId])
  @@index([emailVerified])
}

//
// Auth.js / NextAuth PrismaAdapter models
// See adapter expectations for VerificationToken, Account, Session.
//
model Account {
  id                String @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String

  refresh_token String?
  access_token  String?
  expires_at    Int?
  token_type    String?
  scope         String?
  id_token      String?
  session_state String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
  @@index([expires])
}

//
// TP 3.3 — Events (Messen)
//
model Event {
  id       String @id @default(cuid(2))
  tenantId String

  name     String
  location String?
  startsAt DateTime?
  endsAt   DateTime?

  status    EventStatus @default(DRAFT)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Leads tagged with this event
  leads Lead[] @relation("EventLeads")

  // Devices bound to this event (activeEventId)
  activeDevices MobileDevice[] @relation("ActiveEvent")

  @@index([tenantId, status])
  @@index([tenantId, startsAt])
}

//
// TP 1.0 — Core Domain Models (Forms / Fields / Leads / Attachments / ExportJob)
//
model Form {
  id          String     @id @default(cuid())
  tenantId    String
  name        String
  description String?
  status      FormStatus @default(DRAFT)
  config      Json?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  tenant Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  fields FormField[]
  leads  Lead[]

  // TP 2.5 — Assignments (Device ↔ Form)
  deviceAssignments MobileDeviceForm[]

  @@index([tenantId, status])
}

model FormField {
  id          String    @id @default(cuid())
  tenantId    String
  formId      String
  key         String
  label       String
  type        FieldType
  required    Boolean   @default(false)
  isActive    Boolean   @default(true)
  sortOrder   Int       @default(0)
  placeholder String?
  helpText    String?
  config      Json?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  form   Form   @relation(fields: [formId], references: [id], onDelete: Cascade)

  @@unique([formId, key])
  @@index([tenantId, formId, isActive, sortOrder])
}

model Lead {
  id       String @id @default(cuid())
  tenantId String
  formId   String

  // TP 3.3 — Event tagging (optional, server-side)
  eventId String?

  // Idempotency (Mobile retry-safe)
  clientLeadId String

  capturedAt DateTime @default(now())
  values     Json
  meta       Json?

  //
  // TP 4.3 — Lead Contact (stable for CSV export: contact_*)
  //
  contactFirstName String?
  contactLastName  String?
  contactEmail     String?
  contactPhone     String?
  contactMobile    String?
  contactCompany   String?
  contactTitle     String?
  contactWebsite   String?
  contactStreet    String?
  contactZip       String?
  contactCity      String?
  contactCountry   String?

  contactSource    LeadContactSource?
  contactUpdatedAt DateTime?

  // OCR result used to apply contact (for ocr_* export meta)
  contactOcrResultId String?
  contactOcrResult   LeadOcrResult? @relation("LeadContactOcrResult", fields: [contactOcrResultId], references: [id], onDelete: SetNull)

  // Soft-delete prepared
  isDeleted       Boolean   @default(false)
  deletedAt       DateTime?
  deletedReason   String?
  deletedByUserId String?

  tenant      Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  form        Form             @relation(fields: [formId], references: [id], onDelete: Cascade)
  attachments LeadAttachment[]

  event Event? @relation("EventLeads", fields: [eventId], references: [id], onDelete: SetNull)

  // TP 4.1/4.3 — OCR
  ocrResults LeadOcrResult[] @relation("LeadOcrResults")

  @@unique([tenantId, clientLeadId])
  @@index([tenantId, formId, capturedAt])
  @@index([tenantId, eventId, capturedAt])
  @@index([tenantId, contactEmail])
  @@index([tenantId, contactCompany])
}

model LeadAttachment {
  id       String @id @default(cuid())
  tenantId String
  leadId   String

  type       AttachmentType
  filename   String
  mimeType   String
  sizeBytes  Int
  storageKey String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  lead   Lead   @relation(fields: [leadId], references: [id], onDelete: Cascade)

  // TP 4.1/4.3 — OCR
  ocrResults LeadOcrResult[]

  @@index([tenantId, leadId])
}

//
// TP 4.1/4.3 — OCR Results (idempotent: one result per attachment+mode per tenant)
// - Attachment (BUSINESS_CARD_IMAGE) remains source of truth.
// - OCR is derived and can be corrected by admin.
// IMPORTANT: DB column "suggestions" is kept, but exposed as parsedContactJson in Prisma via @map.
//
model LeadOcrResult {
  id           String @id @default(cuid())
  tenantId     String
  leadId       String
  attachmentId String

  kind LeadOcrKind

  // TP 4.3 — OCR lifecycle/meta
  mode          LeadOcrMode   @default(ON_DEVICE_LATIN)
  status        LeadOcrStatus @default(COMPLETED)
  engine        LeadOcrEngine @default(MLKIT)
  engineVersion String?
  languageHint  String?

  // Raw + structured
  rawText           String?
  blocksJson        Json?
  parsedContactJson Json?   @map("suggestions")
  confidence        Float?

  // Admin review/corrections
  correctedContactJson Json?
  correctedAt          DateTime?
  correctedByUserId    String?
  correctedByUser      User?     @relation("OcrCorrectedBy", fields: [correctedByUserId], references: [id], onDelete: SetNull)

  // Idempotency + error
  resultHash   String?
  completedAt  DateTime?
  errorCode    String?
  errorMessage String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant     Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  lead       Lead           @relation("LeadOcrResults", fields: [leadId], references: [id], onDelete: Cascade)
  attachment LeadAttachment @relation(fields: [attachmentId], references: [id], onDelete: Cascade)

  // Lead.contactOcrResult back relation (optional; primarily for Prisma relation disambiguation)
  contactLeads Lead[] @relation("LeadContactOcrResult")

  @@unique([tenantId, attachmentId, mode])
  @@index([tenantId, leadId, createdAt])
  @@index([tenantId, status, updatedAt])
  @@index([tenantId, attachmentId, mode])
}

model ExportJob {
  id       String @id @default(cuid())
  tenantId String

  type   ExportJobType   @default(CSV)
  status ExportJobStatus @default(QUEUED)

  params           Json?
  resultStorageKey String?

  queuedAt   DateTime  @default(now())
  startedAt  DateTime?
  finishedAt DateTime?

  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, status, updatedAt])
}

//
// TP 2.5 — Mobile Device Auth (ApiKey + Device + Assignment)
//
model MobileApiKey {
  id       String             @id @default(cuid())
  tenantId String
  name     String
  prefix   String
  keyHash  String
  status   MobileApiKeyStatus @default(ACTIVE)

  createdAt  DateTime  @default(now())
  revokedAt  DateTime?
  lastUsedAt DateTime?

  createdByUserId String?
  createdByUser   User?   @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // 1:1 binding (enforced by MobileDevice.apiKeyId unique)
  device MobileDevice? @relation("MobileApiKeyToDevice")

  @@index([tenantId, status, createdAt])
  @@index([prefix, status])
}

model MobileDevice {
  id       String @id @default(cuid())
  tenantId String
  name     String

  apiKeyId String       @unique
  apiKey   MobileApiKey @relation("MobileApiKeyToDevice", fields: [apiKeyId], references: [id], onDelete: Restrict)

  status     MobileDeviceStatus @default(ACTIVE)
  lastSeenAt DateTime?
  createdAt  DateTime           @default(now())

  // TP 3.3 — Event binding (optional)
  activeEventId String?
  activeEvent   Event?  @relation("ActiveEvent", fields: [activeEventId], references: [id], onDelete: SetNull)

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  assignments MobileDeviceForm[]

  // TP 3.0 — Provision token audit (optional)
  provisionTokensUsed MobileProvisionToken[] @relation("MobileProvisionTokenUsedBy")

  @@index([tenantId, status, createdAt])
  @@index([tenantId, apiKeyId])
  @@index([tenantId, activeEventId])
}

model MobileDeviceForm {
  tenantId String
  deviceId String
  formId   String

  assignedAt DateTime @default(now())

  tenant Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  device MobileDevice @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  form   Form         @relation(fields: [formId], references: [id], onDelete: Cascade)

  @@id([tenantId, deviceId, formId])
  @@index([tenantId, deviceId])
  @@index([tenantId, formId])
}

//
// TP 3.0 — Mobile Provision Tokens
//
model MobileProvisionToken {
  id       String @id @default(cuid())
  tenantId String

  prefix    String
  tokenHash String @unique

  status    MobileProvisionTokenStatus @default(ACTIVE)
  expiresAt DateTime

  usedAt         DateTime?
  usedByDeviceId String?
  usedByDevice   MobileDevice? @relation("MobileProvisionTokenUsedBy", fields: [usedByDeviceId], references: [id], onDelete: SetNull)

  requestedDeviceName String?
  requestedFormIds    Json?

  createdAt       DateTime @default(now())
  createdByUserId String?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, status, expiresAt])
  @@index([tenantId, createdAt])
  @@index([prefix, status])
}

//
// Auth — Password Reset Tokens
//
model PasswordResetToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([expiresAt])
}

//
// Auth — Email Verification Tokens (Registration; optional/legacy)
//
model EmailVerificationToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([expiresAt])
}
